<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
  <TITLE>Propeller GCC Library</TITLE>
</HEAD>
<BODY>

<H1>Contents</H1>
<A HREF="#intro">Introduction</A><BR>
<A HREF="#environment">Environment</A><BR>
<A HREF="#stdio">Standard I/O</A><BR>
<A HREF="#fopen">...fopen</A><BR>
<A HREF="#time">Time Related Functions</A><BR>
<A HREF="#TimeZones">...Time Zones</A><BR>
<A HREF="#drivers">Device Drivers</A><BR>
<A HREF="#WritingDrivers">...Writing New Drivers</A><BR>

<A NAME="intro"><H1>Introduction</H1></A>
<P>
The Propeller GCC Library is an implementation of the standard C
library. It attempts to conform to the C89 version of the standard,
with some C99 extensions. This documentation assumes that the user is
familiar with the C language and C libraries; we will focus on the
Propeller specific details of this library rather than general usage.
</P>

<A NAME="environment"><H1>Environment</H1></A>
<P>
  The <CODE>main</CODE> function has prototype:
<PRE>
  int main(int argc, char *argv[], char *environ[]); 
</PRE>
</P><P>
    <CODE>argv</CODE> are the arguments to the program; this is a NULL
    terminated list of pointers to strings. Conventionally the first
    argument (<CODE>argv[0]</CODE>) is the name of the program. Since
    the Propeller has no operating system, it is up to the application
    to supply arguments. This is done with the global variable
    <CODE>char *_argv[]</CODE>, which is passed directly to main as
    <CODE>argv</CODE>.
</P><P>
    <CODE>argc</CODE> is a count of the arguments to the program, and
    is initialized from <CODE>_argv</CODE> automatically by the
    startup code.
</P><P>
    <CODE>environ</CODE> is a list of environment variables, also NULL
    terminated. As with <CODE>argv</CODE>, this is initialized from a
    global variable, in this case <CODE>char *_environ[]</CODE>. The 
    <CODE>getenv</CODE> library function also
    uses <CODE>_environ</CODE> to look for variables.
</P><P>
    The strings in <CODE>_environ</CODE> should be of the form
    <CODE>VAR=value</CODE>, where "VAR" is the name of the environment
    variable and "value" is its value. At present <CODE>TZ</CODE> is
    the only environment variable that is actually used by the
    library, but some applications may also look at the environment
    and require customized settings.
</P>

<A NAME="stdio"><H1>Stdio</H1></A>
<P>
The standard I/O library implementation ("stdio") is fairly
complete. Unlike in many other systems, stdio is fundamental; it is
not implemented on top of POSIX like functions such
as <CODE>open</CODE> and <CODE>close</CODE>. Rather, there is a
<A HREF="#drivers">driver layer</A> which implements the files that
<CODE>fopen</CODE> operates on.
</P>
<A NAME="FILE"><H2>FILE</H2></A>
<P>
The stdio FILE structure is in most respects fairly conventional. It
contains flags for how the file was opened, a pointer to a buffer, and
a buffer size. Unlike many libraries, the Propeller GCC library does
not automatically use <CODE>malloc</CODE> to allocate the FILE buffer;
rather it defaults to a small character array inside the FILE
structure. Some drivers (particularly for disks and similar devices)
may override this to provide a bigger buffer.
</P>
<P>
The FILE structure also contains an array of driver specific variables
(in <CODE>drvarray</CODE>) which drivers may use for any
purpose they wish. 
</P>

<A NAME="fopen"><H2>fopen</H2></A>
<P>
The <CODE>fopen</CODE> function
takes a string describing the device or file that is to be opened. In
the Propeller GCC library this string should start with a prefix which
specifies the <A HREF="#drivers">driver</A>, followed by a string
which is passed to the driver. The prefix should end with a colon. For
example, to open the simple serial port driver for reading and writing
at 9600 baud, with transmit pin 5 and receive pin 5, do:
<PRE>
  FILE *f = fopen("SSER:9600,5,5", "r+");
</PRE>
Here <CODE>"SSER:"</CODE> is the prefix for the simple serial device,
and <CODE>"9600,5,5"</CODE> are the parameters for the
device. Similarly, opening a file for writing on a DOS file system
might be achieved by something like:
<PRE>
  FILE *f = fopen("DOS:log.txt", "w");
</PRE>
</P>
<A NAME="fopen_driver"><H3>__fopen_driver</H3></A>
<P>
  The <CODE>__fopen_driver</CODE> function is like <CODE>fopen</CODE>,
  but has additional parameters directly specifying the handle and driver to
  use, rather than relying on a prefix. So for example:
<PRE>
  stdin = freopen(stdin, "SSER:9600,5,5", "r");
</PRE>
could also be called as:
<PRE>
  extern _Driver _SimpleSerialDriver;
  stdin = __fopen_driver(stdin, &_SimpleSerialDriver, "9600,5,5", "r");
</PRE>
<CODE>__fopen_driver</CODE> is used internally by <CODE>fopen</CODE>
and <CODE>freopen</CODE>, but may sometimes be useful to application
programmers who need direct control over driver and handle usage.
</P>

<A NAME="time"><H1>Time Related Functions</H1></A>
<P>
There is a normal set of time related functions in the library. The
defines for these are mostly in <CODE>&lt;time.h&gt;</CODE>.
</P>
<H2>Types</H2>
<H3>time_t</H3>
<P>
  The <CODE>time_t</CODE> type is used for keeping track of dates. As
  in POSIX, it
  contains the value <CODE>86400*(days since Jan. 1, 1970) + (seconds
  elapsed today)</CODE>, all in the Coordinated Universal Time (UTC)
  time zone. This is not the same as seconds elapsed since
  Jan. 1, 1970, because leap seconds are ignored (as in POSIX).
</P>
<P>
  Note that unless there is a real time clock on the board (with an
  appropriate driver!) and the
  time zone has been set correctly, the values stored
  in <CODE>time_t</CODE> are almost certainly bogus and should not be
  relied on.
</P>
<H3>clock_t</H3>
<P>
  The <CODE>clock_t</CODE> type contains a count of processor
  cycles. It is a 32 bit type, and so on a typical 80MHz board it will
  roll over in about 54 seconds.
</P>

<A NAME="TimeZones"><H2>Time Zones</H2></A>
<P>
  Some functions (such as <CODE>localtime</CODE>
  or <CODE>strftime</CODE>) make use of time zone settings. The time
  zone is set automatically from the <CODE>TZ</CODE>
  <A HREF="#environment">environment variable</A>. This specifies the
  standard time name, offset from GMT, and (optionally) a daylight
  savings time name. For example, include <CODE>"TZ=EST5EDT"</CODE> as
  one of the strings in the <CODE>_environ</CODE> array for the US
  Eastern time zone.
</P><P>
  Only the North American daylight savings times rules are recognized
  at present, and only the current ones (as of 2011) are implemented.
</P>

<A NAME="drivers"><H1>Device Drivers</H1></A>
<P>
Drivers for the <A HREF="#stdio">standard I/O library</A> may be
written by the user and installed in the system. The library comes
with some default drivers, which are described below.
</P>

<H2>Installing Drivers</H2>
<P>
In the default configuration only the simple serial driver is
installed. This is easily modified by the program at compile time.
The global variable <CODE>_driverlist</CODE> is a NULL terminated
array of pointers to driver structures that should be included. So for
example to include both the simple serial driver and full duplex
serial driver, you would do:
<PRE>
#include &lt;driver.h&gt;
extern _Driver _SimpleSerialDriver;
extern _Driver _FullDuplexSerialDriver;

_Driver *_driverlist[] = {
  &_SimpleSerialDriver,
  &_FullDuplexSerialDriver,
  NULL
};
</PRE>
</P>
<P>
The first driver in the list is the "default" driver, and is used to
open the <CODE>stdin</CODE>, <CODE>stdout</CODE>,
and <CODE>stderr</CODE> FILE descriptors. If you want finer control
over how these files are opened, you can either use
the <CODE>freopen</CODE> function on them at the start of your code,
or define a function <CODE>_InitIO</CODE> which will set up the file
handles.
</P>

<H2>Default Drivers</H2>
<A NAME="simpleserial"><H3>Simple Serial Driver (Prefix SSER:)</H3></A>
<P>
The simple serial port driver 
(<CODE>_Driver _SimpleSerialDriver</CODE>)
is a half duplex driver for generic
serial ports. It defaults to doing I/O at the rate specified in the
<CODE>_baud</CODE> variable (normally 115200 on most boards), with
transmit pin <CODE>_txpin</CODE> and receive pin <CODE>_rxpin</CODE>.
These defaults may be overridden by the string passed
to <CODE>fopen</CODE>. This string contains the baud rate, optionally
followed by a comma and the receive pin number and then another comma
and the transmit pin number, all in decimal notation. So for example
the default 
<PRE>
FILE *f=fopen("SSER:", "r");
</PRE>
is equivalent to
<PRE>
FILE *f=fopen("SSER:115200,31,30", "r");
</PRE>
on most boards.
</P>
<P>
The simple serial driver does not require any additional cogs to
operate.
</P>

<H3>Full Duplex Serial Driver (Prefix FDS:)</H3>
<P>
The full duplex serial driver (<CODE>_Driver
_FullDuplexSerialDriver</CODE>) takes over a cog in order to provide
reliable full duplex communication on a serial line. A separate cog is
needed for every set of transmit and receive pins in use. Like
the <A HREF="#simpleserial">simple serial driver</A>, the full duplex
serial driver defaults to the values in the board
specific <CODE>_baud</CODE>, <CODE>_txpin</CODE>,
and <CODE>_rxpin</CODE> variables, and these may be overridden by
passing a string containing <I>baud</I>,<I>rxpin</I>,<I>txpin</I>.
</P>

<A NAME="WritingDrivers"><H2>Writing New Drivers</H2></A>
<P>
It is fairly straightforward to write a device driver. Drivers are
represented by a <CODE>_Driver</CODE> structure, as defined in
<CODE>&lt;driver.h&gt;</CODE>. This structure has the following
fields, which must be set up by the driver code:
<DL>
  <DT><CODE>const char *prefix</CODE></DT>
  <DD>The file prefix that tells <CODE>fopen</CODE> which driver to
    use; this should end in a colon <CODE>:</CODE></DD>
  <DT><CODE>int (*fopen)(FILE *fp, const char *name, const char *mode)</CODE></DT>
  <DD>A hook called by the <CODE>fopen</CODE>
    function. The <CODE>name</CODE> parameter contains the portion of
    the name passed to <CODE>fopen</CODE> that comes <I>after</I> the
    prefix. <CODE>fp</CODE> is the <CODE>FILE</CODE> structure that
    is being set up. The hook should put any driver specific
    variables that are required into the <CODE>drvarg</CODE> array
    in <CODE>fp</CODE>; if more than 4 longs are required, it should
    allocate memory and put a pointer
    into <CODE>drvarg</CODE>. The <CODE>fopen</CODE> hook should
    return 0 on success, and -1 on failure; in the latter case it
    should set <CODE>errno</CODE> to an appropriate value.</DD>
  <DT><CODE>int (*fclose)(FILE *fp)</CODE></DT>
  <DD>A hook called when a file is being closed; this should free any
    memory allocated by the <CODE>fopen</CODE> hook.</DD>
  <DT><CODE>int (*read)(FILE *fp, unsigned char *buf, int size)</CODE></DT>
  <DT><CODE>int (*write)(FILE *fp, unsigned char *buf, int size)</CODE></DT>
  <DD>These are the I/O functions, called to actually read and write
    data.</DD>
  <DT><CODE>int (*seek)(FILE *fp, long offset, int whence)</CODE></DT>
  <DD>A hook called to change the current read position in the file.
    <CODE>whence</CODE> is one
    of <CODE>SEEK_SET</CODE>, <CODE>SEEK_CUR</CODE>,
    or <CODE>SEEK_END</CODE>, which have the same meanings as they do
    for the <CODE>fseek</CODE> function. A driver need not implement
    the <CODE>seek</CODE> hook; if this hook is set to NULL, then any
    attempt to seek on the file will fail and <CODE>errno</CODE> will
    be set to <CODE>ENOSEEK</CODE>.</DD>

</DL>
</P>

</BODY>
</HTML>
