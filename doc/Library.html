<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
  <TITLE>Propeller GCC Library</TITLE>
</HEAD>
<BODY>

<H1>Introduction</H1>
<P>
The Propeller GCC Library is an implementation of the standard C
library. It attempts to conform to the C89 version of the standard,
with some C99 extensions. This documentation assumes that the user is
familiar with the C language and C libraries; we will focus on the
Propeller specific details of this library rather than general usage.
</P>

<A NAME="stdio"><H1>Stdio</H1></A>
<P>
The standard I/O library implementation ("stdio") is fairly
complete. Unlike in many other systems, stdio is fundamental; it is
not implemented on top of POSIX like functions such
as <CODE>open</CODE> and <CODE>close</CODE>. Rather, there is a
<A HREF="#drivers">driver layer</A> which implements the files that
<CODE>fopen</CODE> operates on.
</P>
<A NAME="FILE"><H2>FILE</H2></A>
<P>
The stdio FILE structure is in most respects fairly conventional. It
contains flags for how the file was opened, a pointer to a buffer, and
a buffer size. Unlike many libraries, the Propeller GCC library does
not automatically use <CODE>malloc</CODE> to allocate the FILE buffer;
rather it defaults to a small character array inside the FILE
structure. Some drivers (particularly for disks and similar devices)
may override this to provide a bigger buffer.
</P>
<P>
The FILE structure also contains an array of driver specific variables
(in <CODE>drvarray</CODE>) which drivers may use for any
purpose they wish. 
</P>

<A NAME="fopen"><H2>fopen</H2></A>
<P>
The <CODE>fopen</CODE> function
takes a string describing the device or file that is to be opened. In
the Propeller GCC library this string should start with a prefix which
specifies the <A HREF="#drivers">driver</A>, followed by a string
which is passed to the driver. The prefix should end with a colon. For
example, to open the simple serial port driver for reading and writing
at 9600 baud, with transmit pin 5 and receive pin 5, do:
<PRE>
  FILE *f = fopen("SSER:9600,5,5", "r+");
</PRE>
Here <CODE>"SSER:"</CODE> is the prefix for the simple serial device,
and <CODE>"9600,5,5"</CODE> are the parameters for the
device. Similarly, opening a file for writing on a DOS file system
might be achieved by something like:
<PRE>
  FILE *f = fopen("DOS:log.txt", "w");
</PRE>
</P>
<A NAME="fopen_driver"><H3>__fopen_driver</H3></A>
<P>
  The <CODE>__fopen_driver</CODE> function is like <CODE>fopen</CODE>,
  but has additional parameters directly specifying the handle and driver to
  use, rather than relying on a prefix. So for example:
<PRE>
  stdin = freopen(stdin, "SSER:9600,5,5", "r");
</PRE>
could also be called as:
<PRE>
  extern _Driver _SimpleSerialDriver;
  stdin = __fopen_driver(stdin, &_SimpleSerialDriver, "9600,5,5", "r");
</PRE>
<CODE>__fopen_driver</CODE> is used internally by <CODE>fopen</CODE>
and <CODE>freopen</CODE>, but may sometimes be useful to application
programmers who need direct control over driver and handle usage.
</P>

<A NAME="time"><H1>Time Related Functions</H1></A>
<P>
There is a normal set of time related functions in the library. The
defines for these are mostly in <CODE>&lt;time.h&gt;</CODE>.
</P>
<H2>Types</H2>
<H3>time_t</H3>
<P>
  The <CODE>time_t</CODE> type is used for keeping track of dates. As
  in POSIX, it
  contains the value <CODE>86400*(days since Jan. 1, 1970) + (seconds
  elapsed today)</CODE>, all in the Coordinated Universal Time (UTC)
  time zone. This is not the same as seconds elapsed since
  Jan. 1, 1970, because leap seconds are ignored (as in POSIX).
</P>
<P>
  Note that unless there is a real time clock on the board (with an
  appropriate driver!) and the
  time zone has been set correctly, the values stored
  in <CODE>time_t</CODE> are almost certainly bogus and should not be
  relied on.
</P>
<H3>clock_t</H3>
<P>
  The <CODE>clock_t</CODE> type contains a count of processor
  cycles. It is a 32 bit type, and so on a typical 80MHz board it will
  roll over in about 54 seconds.
</P>

<A NAME="drivers"><H1>Drivers</H1></A>
<P>
Drivers for the <A HREF="#stdio">standard I/O library</A> may be
written by the user and installed in the system. The library comes
with some default drivers, which are described below.
</P>

<H2>Installing Drivers</H2>
<P>
In the default configuration only the simple serial driver is
installed. This is easily modified by the program at compile time.
The global variable <CODE>_driverlist</CODE> is a NULL terminated
array of pointers to driver structures that should be included. So for
example to include both the simple serial driver and full duplex
serial driver, you would do:
<PRE>
#include &lt;driver.h&gt;
extern _Driver _SimpleSerialDriver;
extern _Driver _FullDuplexSerialDriver;

_Driver *_driverlist[] = {
  &_SimpleSerialDriver,
  &_FullDuplexSerialDriver,
  NULL
};
</PRE>
</P>
<P>
The first driver in the list is the "default" driver, and is used to
open the <CODE>stdin</CODE>, <CODE>stdout</CODE>,
and <CODE>stderr</CODE> FILE descriptors. If you want finer control
over how these files are opened, you can either use
the <CODE>freopen</CODE> function on them at the start of your code,
or define a function <CODE>_InitIO</CODE> which will set up the file
handles.
</P>

<H2>Default Drivers</H2>
<A NAME="simpleserial"><H3>Simple Serial Driver (Prefix SSER:)</H3></A>
<P>
The simple serial port driver 
(<CODE>_Driver _SimpleSerialDriver</CODE>)
is a half duplex driver for generic
serial ports. It defaults to doing I/O at the rate specified in the
<CODE>_baud</CODE> variable (normally 115200 on most boards), with
transmit pin <CODE>_txpin</CODE> and receive pin <CODE>_rxpin</CODE>.
These defaults may be overridden by the string passed
to <CODE>fopen</CODE>. This string contains the baud rate, optionally
followed by a comma and the receive pin number and then another comma
and the transmit pin number, all in decimal notation. So for example
the default 
<PRE>
FILE *f=fopen("SSER:", "r");
</PRE>
is equivalent to
<PRE>
FILE *f=fopen("SSER:115200,31,30", "r");
</PRE>
on most boards.
</P>
<P>
The simple serial driver does not require any additional cogs to
operate.
</P>

<H3>Full Duplex Serial Driver (Prefix FDS:)</H3>
<P>
The full duplex serial driver (<CODE>_Driver
_FullDuplexSerialDriver</CODE>) takes over a cog in order to provide
reliable full duplex communication on a serial line. A separate cog is
needed for every set of transmit and receive pins in use. Like
the <A HREF="#simpleserial">simple serial driver</A>, the full duplex
serial driver defaults to the values in the board
specific <CODE>_baud</CODE>, <CODE>_txpin</CODE>,
and <CODE>_rxpin</CODE> variables, and these may be overridden by
passing a string containing <I>baud</I>,<I>rxpin</I>,<I>txpin</I>.
</P>

<H2>Writing New Drivers</H2>
<P>
</P>

</BODY>
</HTML>
