<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.2  (Unix)">
	<META NAME="AUTHOR" CONTENT="Eric Smith">
	<META NAME="CREATED" CONTENT="20111020;13294300">
	<META NAME="CHANGEDBY" CONTENT="Eric Smith">
	<META NAME="CHANGED" CONTENT="20111020;22264200">
	<META NAME="CHANGEDBY" CONTENT="Eric Smith">
	<META NAME="CHANGEDBY" CONTENT="Eric Smith">
	<META NAME="CHANGEDBY" CONTENT="Eric Smith">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2cm }
		P { margin-bottom: 0.21cm }
		H1 { margin-bottom: 0.21cm }
		H1.western { font-family: "Arial", sans-serif; font-size: 16pt }
		H1.cjk { font-family: "DejaVu Sans"; font-size: 16pt }
		H1.ctl { font-family: "DejaVu Sans"; font-size: 16pt }
		H2 { margin-bottom: 0.21cm }
		H2.western { font-family: "Arial", sans-serif; font-size: 14pt; font-style: italic }
		H2.cjk { font-size: 14pt; font-style: italic }
		H2.ctl { font-size: 14pt; font-style: italic }
		H3.western { font-family: "Albany", sans-serif }
		H3.cjk { font-family: "HG Mincho Light J" }
		H3.ctl { font-family: "Arial Unicode MS" }
		A:link { so-language: zxx }
		CODE.cjk { font-family: "DejaVu Sans", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-CA" DIR="LTR">
<H1 CLASS="western">Memory Models</H1>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">The Propeller port of GCC supports a
number of memory models, or ways of storing the program in memory.
Basically these models provide a trade off of speed for code space.
By far the fastest model is the native “cog” model (-<CODE CLASS="western">mcog</CODE>)
in which machine instructions are executed directly. However, in that
model only the 2K of internal memory (actually slightly less) is
available for code. In the other models (LMM, XMMC, and XMM) code is
stored in RAM external to the cog and is loaded in by a small kernel.
This makes more space available for the code (and, in the XMM case,
the data) but at the cost of having kernel overhead on each
instruction executed.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">COG</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">As previously mentioned, in the COG
memory model code is stored directly in the internal memory of the
Propeller's cogs. This memory is 512 words, or 2048 bytes, long, but
16 words are reserved for hardware registers. The GNU C compiler
reserves an additional 17 words for compiler registers. These
registers, named <CODE CLASS="western">r0</CODE>-<CODE CLASS="western">r14</CODE>,<CODE CLASS="western">
lr</CODE>, and <CODE CLASS="western">sp</CODE>, are used by the
compiler for various purposes. <CODE CLASS="western">r0</CODE>-<CODE CLASS="western">r7</CODE>
are temporary registers within a function (not preserved across
function calls). <CODE CLASS="western">r8</CODE>-<CODE CLASS="western">r14</CODE>
are working registers within a function and are preserved across
function calls. <CODE CLASS="western">lr</CODE> is the “link
register” which holds the return address for functions (except for
functions declared with the “native” attribute, for which the
return address is stored directly in the <CODE CLASS="western">ret</CODE>
instruction). <CODE CLASS="western">sp</CODE> is the stack pointer.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H3 CLASS="western">Assembly programming in COG mode</H3>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Inline assembly (or writing external C
callable functions in assembly) in COG mode is very straightforward –
the Propeller instruction set is directly usable. The GNU assembler
gas accepts input that is very similar to PASM. The major differences
are: (1) gas does not understand local labels (labels that start with
:, and (2) by default addresses are considered to be byte addresses
rather than word addresses; you can tell gas to treat them as words
by using the <CODE CLASS="western">.cog_ram</CODE> directive. The
instruction set is the same, although for convenience gas offers a
<CODE CLASS="western">mova</CODE> (“move address”) instruction
that works just like <CODE CLASS="western">mov</CODE> but which
divides any immediate source value by 4, thus converting it from a
byte address to a word address. <CODE CLASS="western">mova</CODE> is
not needed in .cog_ram mode, but is convenient in the default mode.</P>
<H2 CLASS="western">LMM</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">In the Large Memory Model (LMM mode),
the program code is stored in hub memory, which is 32K in size. The
program's data and stack are also stored there. A small kernel
program (the “LMM Kernel”) runs in COG memory and loads and
executes program instructions from hub memory. In this mode the same
17 compiler registers are available as in hub mode (<CODE CLASS="western">r0</CODE>-<CODE CLASS="western">r14</CODE>,
<CODE CLASS="western">lr</CODE>, and <CODE CLASS="western">sp</CODE>),
but there is an additional register <CODE CLASS="western">pc</CODE>
which is a pointer to the next instruction to be fetched.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H3 CLASS="western">Assembly programming in LMM mode</H3>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">In LMM mode most PASM instructions can
be used, except for any jump or call instructions (including <CODE CLASS="western">djnz</CODE>,
<CODE CLASS="western">tjnz</CODE>, and <CODE CLASS="western">jmpret</CODE>).
Instead of doing direct jumps, we have to modify the value of the <CODE CLASS="western">pc</CODE>
register used by the LMM interpreter instead. This may be done either
by directly adding an offset to <CODE CLASS="western">pc</CODE>, or
by loading a new value into it. gas provides a pseudo-instruction <CODE CLASS="western">brs</CODE>
(“branch short”) which translates into an immediate <CODE CLASS="western">add</CODE>
or <CODE CLASS="western">sub</CODE> of the <CODE CLASS="western">pc</CODE>;
this may be used to branch to a destination within 508 bytes (plus or
minus) of the instruction following the <CODE CLASS="western">brs</CODE>.
For longer branches we can use the <CODE CLASS="western">__LMM_JMP</CODE>
routine built into the kernel, or else move a different register into
<CODE CLASS="western">pc</CODE> (for an indirect jump). After the <CODE CLASS="western">jmp
#__LMM_JMP</CODE> instruction comes a 4 byte address indicating the
new value for the <CODE CLASS="western">pc</CODE>.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Calls are handled by the <CODE CLASS="western">__LMM_CALL</CODE>
and <CODE CLASS="western">__LMM_CALL_INDIRECT</CODE> kernel
functions. <CODE CLASS="western">__LMM_CALL</CODE> is like <CODE CLASS="western">__LMM_JMP</CODE>
except that before it loads the new <CODE CLASS="western">pc</CODE>
it saves the old value into the <CODE CLASS="western">lr</CODE>
register. The called function can thus return with a simple <CODE CLASS="western">mov
pc,lr</CODE> instruction. <CODE CLASS="western">__LMM_CALL_INDIRECT</CODE>
uses a special register, <CODE CLASS="western">__TMP0</CODE>, as the
address to call; thus, an indirect call via compiler register <CODE CLASS="western">r6</CODE>
would be coded as:</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">mov __TMP0, r6</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">jmp
#__LMM_CALL_INDIRECT</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">__LMM_CALL_INDIRECT</CODE>
also saves the return address in <CODE CLASS="western">lr</CODE>.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">XMMC</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">In the eXtended Memory Model – Code
(XMMC mode) the program code is stored in external memory, either
flash or ram. The exact size of this memory depends on the board
used, but it is generally quite a bit larger than hub memory. The
program's data and stack reside in hub memory as in LMM mode.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Assembly programming in XMMC mode is
exactly the same as in LMM mode.</P>
<H2 CLASS="western">XMM</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">In the eXtended Memory Model both the
code and data are placed in external memory (in the case of data it
must be an external RAM). This allows for the largest possible
programs, but at a considerable cost in execution time, since all
data accesses must go through functions in the XMM kernel. As in all
other modes, the stack remains in hub memory (and hence is limited to
32K bytes less the cache size used by the XMM kernel, which is
typically 8K bytes).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Assembly programming in XMM mode is
very similar to LMM mode, except that data accesses which may point
into external memory must be done via the appropriate kernel
functions instead of directly with <CODE CLASS="western">rdlong</CODE>
and <CODE CLASS="western">wrlong</CODE> instructions.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H1 CLASS="western">Kernel APIs</H1>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">The LMM, XMM, and XMMC kernels all
provide some common functions which may be used by programs (and
which the compiler takes advantage of).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">Data movement</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">jmp #__LMM_MVI_rn</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">long val</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">This is a “move immediate”
instruction to move the value “val” into compiler register <CODE CLASS="western">rn</CODE>
(or the link register <CODE CLASS="western">lr</CODE>). After the
instruction is complete the LMM interpreter resumes automatically.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">mov __TMP0,
#(count&lt;&lt;4)|regnum</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__LMM_PUSHM</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Push multiple compiler registers onto
the stack. “count” is the number of registers to push, and
“regnum” is the number of the first register to push (0 for <CODE CLASS="western">r0</CODE>,
1 for <CODE CLASS="western">r1</CODE>, and so on; register number 15
is <CODE CLASS="western">lr</CODE>). Note that “count+regnum”
should be less than or equal to 16. The registers count up, so if
regnum is 12 and count is 3 then <CODE CLASS="western">r12</CODE>,
<CODE CLASS="western">r13</CODE>, and <CODE CLASS="western">r14</CODE>
will be pushed (in that order).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">mov __TMP0,
#(count&lt;&lt;4)|regnum</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__LMM_POPM</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Pop multiple compiler registers from
the stack. “count” is the number of registers to pop, and
“regnum” is the number of the first register to pop, which should
be the last register pushed (0 for <CODE CLASS="western">r0</CODE>, 1
for <CODE CLASS="western">r1</CODE>, and so on). Note that
“count+regnum” should be less than or equal to 16. The registers
count down, so if regnum is 14 and count is 3 then <CODE CLASS="western">r14</CODE>,
<CODE CLASS="western">r13</CODE>, and <CODE CLASS="western">r12</CODE>
will be popped (in that order).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">Branches and calls</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">jmp #__LMM_JMP</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">long addr</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Moves the immediate value <CODE CLASS="western">addr</CODE>
into the <CODE CLASS="western">pc</CODE> register (so the LMM
interpreter will begin to execute at address <CODE CLASS="western">addr</CODE>,
thus performing an unconditional jump).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">jmp #__LMM_CALL</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">long addr</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Moves the address of the next
instruction into the <CODE CLASS="western">lr</CODE> register, and
moves <CODE CLASS="western">addr</CODE> into the <CODE CLASS="western">pc</CODE>
register (so the LMM interpreter will begin execution at address
<CODE CLASS="western">addr</CODE>, which is typically a subroutine).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">mov __TMP0,rn</CODE></P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">jmp
#__LMM_CALL_INDIRECT</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Moves the address of the next
instruction into the <CODE CLASS="western">lr</CODE> register, and
moves <CODE CLASS="western">__TMP0</CODE> into the <CODE CLASS="western">pc</CODE>
register (so the LMM interpreter will begin execution at address, it
contained, which is typically a subroutine).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">Math functions</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__UDIVSI</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Performs 32 bit unsigned division of
the value in compiler register r0 by the one in r1. Returns the
quotient in r0, and the remainder in r1.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__DIVSI</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Performs a 32 bit signed division of r0
by r1. Returns the quotient in r0, and the remainder in r1.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__MULSI</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Multiplies the two 32 bit numbers in r0
and r1, and returns the (low order) 32 bits of the result in r0.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__CLZSI</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Counts the number of leading 0 bits in
register r0, and returns the result in r0. For example, if r0 =
0x00008100, then the result will be 16. This is useful for
normalizing fixed and floating point numbers.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">call #__CTZSI</CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Counts the number of trailing 0 bits in
register r0, and returns the result in r0. For example, if r0 =
0x00008100, then the result will be 8.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
</BODY>
</HTML>