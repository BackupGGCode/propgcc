;; Machine description for Propeller
;; Copyright (C) 2011 Parallax, Inc.
;; Copyright (C) 2009 Free Software Foundation, Inc.
;; Contributed by Eric R. Smith <ersmith@totalspectrum.ca>
;; Based in part on the Moxie machine description
;;   contributed by Anthony Green <green@moxielogic.com>

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.

;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; -------------------------------------------------------------------------
;; Propeller specific constraints, predicates and attributes
;; -------------------------------------------------------------------------

; make sure this matches the definition in propeller.h
(define_constants
  [(CC_REG 18)
   (SP_REG 16)
   (UNSPEC_NAKED   32)
  ])

; Most instructions are four bytes long.
(define_attr "length" "" (const_int 4))

(include "constraints.md")
(include "predicates.md")

;;
;; instruction types
;; core == normal instruction
;; call == subroutine call
;; hub  == instruction that references hub memory
;; multi == an insn that expands to multiple instructions
;;
(define_attr "type" "core,call,hub,multi" (const_string "core"))

; condition codes: this one is used by final_prescan_insn to speed up
; conditionalizing instructions.  It saves having to scan the rtl to see if
; it uses or alters the condition codes.
; 
; USE means that the condition codes are used by the insn in the process of
;   outputting code, this means (at present) that we can't use the insn in
;   inlined branches
;
; SET means that the purpose of the insn is to set the condition codes in a
;   well defined manner.
;
; CLOB means that the condition codes are altered in an undefined manner, if
;   they are altered at all
;
; UNCONDITIONAL means the instruction can not be conditionally executed and
;   that the instruction does not use or alter the condition codes.
;
; NOCOND means that the instruction does not use or alter the condition
;   codes but can be converted into a conditionally exectuted instruction.

(define_attr "conds" "use,set,clob,unconditional,nocond"
	(if_then_else
	 (ior
           (eq_attr "type" "call")
           (eq_attr "type" "multi"))
	 (const_string "clob")
         (const_string "nocond")))

; Predicable means that the insn can be conditionally executed based on
; an automatically added predicate (additional patterns are generated by 
; gen...).
(define_attr "predicable" "no,yes" (const_string "yes"))

;;
;; the user's __asm__ instruction has the following attributes
;;
(define_asm_attributes
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
  (set_attr "predicable" "no")
 ])


;; -------------------------------------------------------------------------
;; machine model for instruction scheduling
;; the tricky part here is that hub memory operations are only available
;; every 16 cycles (4 instructions) and that 16 cycle period is independent
;; of what's going on inside the processor -- if we miss a hub window we
;; have to wait for the next one to come along
;;
;; we model this by pretending there are 4 slots; core operations issue
;; to any of the slots, hub operations can only issue to slot1
;; -------------------------------------------------------------------------
(define_cpu_unit "issue,slot1,slot2,slot3,slot4")

(define_reservation "use_slot1" "(issue+slot1),slot1*3")
(define_reservation "use_slot2" "(issue+slot2),slot2*3")
(define_reservation "use_slot3" "(issue+slot3),slot3*3")
(define_reservation "use_slot4" "(issue+slot4),slot4*3")

(define_insn_reservation "coreop" 1 (eq_attr "type" "core")
			 "use_slot1 | use_slot2 | use_slot3 | use_slot4")
(define_insn_reservation "hubop" 1 (eq_attr "type" "hub")
			 "(issue+slot1+slot2),(slot1+slot2)*3")
(define_insn_reservation "multiop" 1 (eq_attr "type" "multi")
			 "issue+slot1,nothing*3")

;; -------------------------------------------------------------------------
;; general template for conditional execution
;; -------------------------------------------------------------------------
(define_cond_exec
  [(match_operator 0 "predicate_operator"
    [(match_operand 1 "cc_register" "")
     (const_int 0)])]
  ""
  "%J0"
)

;; -------------------------------------------------------------------------
;; the instruction set is pretty regular, so we define some iterators
;; to make repetitive patterns easier
;; -------------------------------------------------------------------------

(define_code_iterator logicop     [(ior "") (xor "")])
(define_code_attr     logicopcode [(ior "or") (xor "xor")])

;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI    0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI
	   (match_operand:SI 1 "propeller_dst_operand" "%0,0")
	   (match_operand:SI 2 "propeller_add_operand" " rCI,N")))]
  ""
  "@
  add\t%0, %2
  sub\t%0, #%n2")

(define_insn "subsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	  (minus:SI
	   (match_operand:SI 1 "propeller_dst_operand" "0,0")
	   (match_operand:SI 2 "propeller_src_operand" "I,rC")))]
  ""
  "@
  sub\t%0, %2
  sub\t%0, %2")

;; -------------------------------------------------------------------------
;; Unary arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "negsi2"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	(neg:SI (match_operand:SI 1 "propeller_src_operand" "rCI")))]
  ""
  "neg\t%0, %1")

;;
;; the instruction set doesn't actually have a NOT instruction, so synthesize
;; it from XOR; we'll just put a handy 0xFFFFFFFF somewhere in cog memory
;;
;;
(define_insn "one_cmplsi2"
  [ (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
         (not:SI (match_operand:SI 1 "propeller_src_operand" "0")))]
  ""
{
  propeller_need_maskffffffff = true; /* make sure we generate the FFFFFFFF */
  return "xor\t%0,__MASK_FFFFFFFF";
})

;; -------------------------------------------------------------------------
;; Logical operators
;; -------------------------------------------------------------------------

;; and is a little bit odd because the "andn" instruction gives us an
;; opportunity to optimize some constants


(define_insn "*andnotsi3"
  [(set (match_operand:SI                 0 "propeller_dst_operand" "=rC")
	(and:SI (not:SI (match_operand:SI 1 "propeller_src_operand" " rCI"))
		(match_operand:SI         2 "propeller_dst_operand" " 0")))]
  ""
  "andn\t%0, %1"
)

(define_insn "andsi3"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC,rC")
	(and:SI (match_operand:SI 1 "propeller_dst_operand" "%0,0")
		(match_operand:SI 2 "propeller_and_operand" " rCI,M")))]
  ""
  "@
   and\t%0, %2
   andn\t%0, %M2"
)

;; version that checks against 0
(define_insn "*andsi3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (and:SI
	    (match_operand:SI 0 "propeller_src_operand" "rC,rC")
            (match_operand:SI 1 "propeller_and_operand" "rCI,M"))
          (const_int 0)))
   ]
  ""
  "@
   test\t%0,%1 wz
   testn\t%0,%1 wz"
  [(set_attr "conds" "set")]
)

; xor and ior are very regular, we can use the logicalop iterator for them

(define_insn "<logicop:code>si3"
  [(set (match_operand:SI             0 "propeller_dst_operand" "=rC")
	(logicop:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
	            (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "<logicopcode>\t%0, %2"
)

(define_insn "*<logicop:code>si3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (logicop:SI
	    (match_operand:SI 0 "propeller_src_operand" "rC")
            (match_operand:SI 1 "propeller_dst_operand" "rCI"))
          (const_int 0)))
   ]
  ""
  "<logicopcode>\t%0, %1 wz,nr"
  [(set_attr "conds" "set")]
)

;; -------------------------------------------------------------------------
;; Shifters
;; -------------------------------------------------------------------------

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(ashift:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		   (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "shl\t%0, %2"
)

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(ashiftrt:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "sar\t%0, %2"
)

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(lshiftrt:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "shr\t%0, %2"
)

;; -------------------------------------------------------------------------
;; Move instructions
;; -------------------------------------------------------------------------

;; SImode

(define_expand "movsi"
   [(set (match_operand:SI 0 "general_operand" "")
 	(match_operand:SI 1 "general_operand" ""))]
   ""
  "
{
  /* If this is a store, force the value into a register.  */
  if (! (reload_in_progress || reload_completed))
  {
    if (MEM_P (operands[0]))
    {
      operands[1] = force_reg (SImode, operands[1]);
      if (MEM_P (XEXP (operands[0], 0)))
        operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));
    }
    else 
      if (MEM_P (operands[1])
          && MEM_P (XEXP (operands[1], 0)))
        operands[1] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[1], 0)));
  }
}")

(define_insn "*movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=rC,rC,rC,Q")
	(match_operand:SI 1 "general_operand"               "rCIB,N,Q,rC"))]
  "register_operand (operands[0], SImode)
   || register_operand (operands[1], SImode)"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdlong\t%0, %1
   wrlong\t%1, %0"
   [(set_attr "type" "core,core,hub,hub")]
)


(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  if (MEM_P (operands[0]))
    operands[1] = force_reg (HImode, operands[1]);
}")

(define_insn "*movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand"          "=rC,rC,rC,Q")
	(match_operand:HI 1 "general_operand" "rCI,N,Q,rC"))]
  "register_operand (operands[0], HImode)
   || register_operand (operands[1], HImode)"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdword\t%0, %1
   wrword\t%1, %0"
   [(set_attr "type" "core,core,hub,hub")]
)

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  if (MEM_P (operands[0]))
    operands[1] = force_reg (QImode, operands[1]);
}")

(define_insn "*movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand"   "=r,r,r,Q")
	(match_operand:QI 1 "general_operand"        "rI,N,Q,r"))]
  "register_operand (operands[0], QImode)
   || register_operand (operands[1], QImode)"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdbyte\t%0, %1
   wrbyte\t%1, %0"
   [(set_attr "type" "core,core,hub,hub")]
)

;; -------------------------------------------------------------------------
;; extending qi and hi to si
;; the default gcc way of extending (using shifts) is fine for
;; extending hi to si and for sign extensions, but for zero extension
;; "and" is better
;; -------------------------------------------------------------------------
(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,m")))]
  ""
{
  switch(which_alternative) {
    case 0:
      propeller_need_mask0000ffff = true;
      return "and\\t%0,__MASK_0000FFFF";
    case 1:
      return "rdword\\t%0, %1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub")]
)
(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,m")))]
  ""
{
  switch(which_alternative) {
    case 0:
      return "and\\t%0,#255";
    case 1:
      return "rdbyte\\t%0, %1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub")]
)

;; -------------------------------------------------------------------------
;; multiply
;; on propeller 1 multiply has to be implemented in software; we do this
;; by calling in to a library function which takes r0,r1 and returns r0
;; the function is allowed to clobber r1, r2, and the condition codes
;; -------------------------------------------------------------------------

;; We must use a pseudo-reg forced to reg 0 in the SET_DEST rather than
;; hard register 0.  If we used hard register 0, then the next instruction
;; would be a move from hard register 0 to a pseudo-reg.  If the pseudo-reg
;; gets allocated to a stack slot that needs its address reloaded, then
;; there is nothing to prevent reload from using r0 to reload the address.
;; This reload would clobber the value in r0 we are trying to store.
;; If we let reload allocate r0, then this problem can never happen.

(define_insn "*prop_mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (mult:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:SI 1))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_mulsi = true;
  return "call\t#__MULSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "mulsi3"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(mult:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:SI 1))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
"")

;; -------------------------------------------------------------------------
;; divide
;; on propeller 1 divide has to be implemented in software; we do this
;; by calling in to a library function which takes r0,r1 and returns
;; r0/r1 in r0 and r0%r1 in r1
;; -------------------------------------------------------------------------

(define_insn "*prop_udivmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (udiv:SI (reg:SI 0)(reg:SI 1)))
   (set (match_operand:SI 1 "register_operand" "=y")
        (umod:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_udivsi = true;
  return "call\t#__UDIVSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "udivmodsi4"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(udiv:SI (reg:SI 0)(reg:SI 1)))
     (set (reg:SI 1)(umod:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
   (set (match_operand:SI 3 "propeller_dst_operand" "")(reg:SI 1))
  ]
""
"")

(define_insn "*prop_divmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (div:SI (reg:SI 0)(reg:SI 1)))
   (set (match_operand:SI 1 "register_operand" "=y")
        (mod:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_divsi = true;
  return "call\t#__DIVSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "divmodsi4"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(div:SI (reg:SI 0)(reg:SI 1)))
     (set (reg:SI 1)(mod:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
   (set (match_operand:SI 3 "propeller_dst_operand" "")(reg:SI 1))
  ]
""
"")

;; -------------------------------------------------------------------------
;; min/max instructions
;; NOTE!! The Propeller instruction names are the reverse of what one
;; might expect: the "max X,Y" instruction does X := (X > Y) ? Y : X
;; -------------------------------------------------------------------------
(define_insn "umaxsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(umax:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "min\\t%0, %2")

(define_insn "uminsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(umin:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "max\\t%0, %2")

(define_insn "smaxsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(smax:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "mins\\t%0, %2")

(define_insn "sminsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(smin:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "maxs\\t%0, %2")

;; -------------------------------------------------------------------------
;; Compare instructions
;; -------------------------------------------------------------------------

(define_expand "cbranchsi4"
  [(set (match_dup 4)
        (match_op_dup 5
         [(match_operand:SI 1 "propeller_dst_operand" "")
          (match_operand:SI 2 "propeller_src_operand" "")]))
   (set (pc)
        (if_then_else
              (match_operator 0 "ordered_comparison_operator"
               [(match_dup 4)
                (const_int 0)])
              (label_ref (match_operand 3 "" ""))
              (pc)))]
  ""
  "
{
  operands[4] = propeller_gen_compare_reg (GET_CODE (operands[0]),
                                      operands[1], operands[2]);
  operands[5] = gen_rtx_fmt_ee (COMPARE,
                                GET_MODE (operands[4]),
                                operands[1], operands[2]);
}")

(define_insn "*cmpu"
  [(set (reg:CCUNS CC_REG)
	(compare
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmp\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)

(define_insn "*cmpz"
  [(set (reg:CC_Z CC_REG)
	(compare
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmp\t%0, %1 wz"
  [(set_attr "conds" "set")]
)

(define_insn "*cmps"
  [(set (reg:CC CC_REG)
	(compare
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmps\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)


;; -------------------------------------------------------------------------
;; Branch instructions
;; -------------------------------------------------------------------------

(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
(define_code_attr CC [(ne "NE") (eq "E ") (lt "B ") (ltu "B ") 
		      (gt "A ") (gtu "A ") (ge "AE") (le "BE") 
		      (geu "AE") (leu "BE") ])

(define_insn "*b<cond:code>"
  [(set (pc)
	(if_then_else (cond (reg CC_REG)
			    (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
{
  return "IF_<CC> jmp\t#%l0";
}
[(set_attr "conds" "use")]
)


;; -------------------------------------------------------------------------
;; Call and Jump instructions
;; -------------------------------------------------------------------------

(define_expand "call"
  [(call (match_operand:SI 0 "memory_operand" "")
		(match_operand 1 "general_operand" ""))]
  ""
{
  gcc_assert (MEM_P (operands[0]));
})

(define_insn "*call"
  [(call (mem:SI (match_operand:SI
		  0 "call_operand" "i,r"))
	 (match_operand 1 "" ""))]
  ""
  "@
   jmpret\tlr,#%0
   jmpret\tlr,%0"
  [(set_attr "type" "call")]
)

(define_expand "call_value"
  [(set (match_operand 0 "" "")
		(call (match_operand:SI 1 "memory_operand" "")
		 (match_operand 2 "" "")))]
  ""
{
  gcc_assert (MEM_P (operands[1]));
})

(define_insn "*call_value"
  [(set (match_operand 0 "propeller_dst_operand" "=rC,rC")
	(call (mem:SI (match_operand:SI 1 "call_operand" "i,rC"))
	      (match_operand 2 "" "")))]
  ""
  "@
   jmpret\tlr,#%1
   jmpret\tlr,%1"
  [(set_attr "type" "call")]
 )

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "rC"))]
  ""
  "jmp\t%0")

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp\t#%0")


;; -------------------------------------------------------------------------
;; Prologue & Epilogue
;; -------------------------------------------------------------------------

(define_expand "prologue"
  [(clobber (const_int 0))]
  ""
  "
{
  propeller_expand_prologue ();
  DONE;
}
")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  propeller_expand_epilogue (false);
  DONE;
}
")

(define_insn "return_internal"
  [(use (match_operand:SI 0 "register_operand" "r"))
   (return)]
  ""
  "jmp\t%0"
)

(define_insn "naked_return"
  [(unspec_volatile [(return)] UNSPEC_NAKED) ]
  ""
  "; Naked function: epilogue provided by programmer."
)

(define_insn "return"
  [(return)]
  "propeller_can_use_return ()"
  "jmp\tlr"
)


;; -------------------------------------------------------------------------
;; Some library functions
;; -------------------------------------------------------------------------
;;
;; count leading zeros
;;

(define_insn "*prop_clzsi2"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (clz:SI (reg:SI 0)))
   (clobber (reg:CC CC_REG))]
""
{
  propeller_need_clzsi = true;
  return "call\t#__CLZSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")]
)

;; count trailing zeros
(define_insn "*prop_ctzsi2"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (ctz:SI (reg:SI 0)))
   (clobber (reg:CC CC_REG))]
""
{
  propeller_need_clzsi = true;
  return "jmpret\t__CLZSI_ret,#__CTZSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")]
)

(define_expand "clzsi2"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(clz:SI (reg:SI 0)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
""
)

(define_expand "ctzsi2"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(ctz:SI (reg:SI 0)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
""
)
